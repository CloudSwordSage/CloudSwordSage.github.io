const t='{"documentCount":32,"nextId":32,"documentIds":{"0":"/article/5072dy3i/","1":"/article/5072dy3i/#冒泡排序","2":"/article/zcuvoi0z/","3":"/article/33zhvues/","4":"/article/5072dy3i/#算法步骤","5":"/article/zcuvoi0z/#基数排序","6":"/article/fslzy69j/","7":"/article/33zhvues/#堆排序","8":"/article/5072dy3i/#code","9":"/article/zcuvoi0z/#算法步骤","10":"/article/fslzy69j/#归并排序","11":"/article/su2chqg1/","12":"/article/33zhvues/#堆排序流程","13":"/article/zcuvoi0z/#code","14":"/article/fslzy69j/#算法步骤","15":"/article/su2chqg1/#快速排序","16":"/article/jbadeaso/","17":"/article/33zhvues/#堆排序实现","18":"/article/fslzy69j/#code","19":"/article/su2chqg1/#荷兰国旗问题","20":"/article/jbadeaso/#插入排序","21":"/article/4we28dl1/","22":"/article/33zhvues/#堆排序时间复杂度","23":"/article/su2chqg1/#思路","24":"/article/jbadeaso/#算法步骤","25":"/article/4we28dl1/#算法描述","26":"/article/su2chqg1/#快速排序-1","27":"/article/jbadeaso/#code","28":"/article/4we28dl1/#算法步骤","29":"/article/su2chqg1/#代码实现","30":"/article/4we28dl1/#code","31":"/article/su2chqg1/#复杂度分析"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,2],"1":[1,1,11],"2":[1,1,2],"3":[1,1,2],"4":[1,1,12],"5":[1,1,11],"6":[1,1,2],"7":[1,1,17],"8":[1,1,16],"9":[1,1,8],"10":[1,1,11],"11":[1,1,2],"12":[1,1,8],"13":[1,1,28],"14":[1,1,16],"15":[1,1,8],"16":[1,1,2],"17":[1,1,33],"18":[1,1,30],"19":[1,1,10],"20":[1,1,12],"21":[1,1,2],"22":[1,1,3],"23":[1,2,21],"24":[1,1,13],"25":[1,1,12],"26":[1,1,10],"27":[1,1,23],"28":[1,1,9],"29":[1,1,34],"30":[1,1,18],"31":[1,1,7]},"averageFieldLength":[1,1.03125,12.34375],"storedFields":{"0":{"title":"冒泡排序","titles":[]},"1":{"title":"冒泡排序","titles":["冒泡排序"]},"2":{"title":"基数排序","titles":[]},"3":{"title":"堆排序","titles":[]},"4":{"title":"算法步骤","titles":["冒泡排序"]},"5":{"title":"基数排序","titles":["基数排序"]},"6":{"title":"归并排序","titles":[]},"7":{"title":"堆排序","titles":["堆排序"]},"8":{"title":"CODE","titles":["冒泡排序"]},"9":{"title":"算法步骤","titles":["基数排序"]},"10":{"title":"归并排序","titles":["归并排序"]},"11":{"title":"快速排序","titles":[]},"12":{"title":"堆排序流程","titles":["堆排序"]},"13":{"title":"CODE","titles":["基数排序"]},"14":{"title":"算法步骤","titles":["归并排序"]},"15":{"title":"快速排序","titles":["快速排序"]},"16":{"title":"插入排序","titles":[]},"17":{"title":"堆排序实现","titles":["堆排序"]},"18":{"title":"CODE","titles":["归并排序"]},"19":{"title":"荷兰国旗问题","titles":["快速排序"]},"20":{"title":"插入排序","titles":[]},"21":{"title":"选择排序","titles":[]},"22":{"title":"堆排序时间复杂度","titles":["堆排序"]},"23":{"title":"思路","titles":["快速排序","荷兰国旗问题"]},"24":{"title":"算法步骤","titles":["插入排序"]},"25":{"title":"算法描述","titles":["选择排序"]},"26":{"title":"快速排序","titles":["快速排序"]},"27":{"title":"CODE","titles":["插入排序"]},"28":{"title":"算法步骤","titles":["选择排序"]},"29":{"title":"代码实现","titles":["快速排序"]},"30":{"title":"CODE","titles":["选择排序"]},"31":{"title":"复杂度分析","titles":["快速排序"]}},"dirtCount":0,"index":[["时间复杂度为o",{"2":{"31":1}}],["时间复杂度o",{"2":{"19":1}}],["通过计算数学期望",{"2":{"31":1}}],["通常采用in",{"2":{"20":1}}],["但由于快速排序使用了随机数",{"2":{"31":1}}],["复杂度分析",{"0":{"31":1}}],["elif",{"2":{"29":1}}],["else",{"2":{"18":1,"29":1}}],["quick",{"2":{"29":1}}],["代码实现",{"0":{"29":1}}],["移动数据",{"2":{"27":1}}],["移动指针",{"2":{"14":1}}],["pivot",{"2":{"29":6}}],["partition",{"2":{"29":2}}],["preindex",{"2":{"27":7}}],["place算法方式",{"2":{"20":1}}],["结束递归",{"2":{"26":1}}],["结束循环",{"2":{"23":1}}],["递归调用",{"2":{"26":2}}],["递归分解数组",{"2":{"14":1}}],["以基准数作为荷兰国旗问题的num",{"2":{"26":1}}],["以此类推",{"2":{"25":1,"28":1}}],["作为基准数",{"2":{"26":1}}],["随机选择一个数",{"2":{"26":1}}],["再从剩余未排序元素中继续寻找最小",{"2":{"25":1}}],["存放到排序序列的起始位置",{"2":{"25":1,"28":1}}],["元素",{"2":{"25":2,"28":2}}],["元素就变成了最大值",{"2":{"7":1}}],["大",{"2":{"25":2,"28":2}}],["大于新元素",{"2":{"24":1}}],["大于num的数more",{"2":{"23":1}}],["大于num的数放在数组的右边",{"2":{"19":1}}],["首先在未排序序列中找到最小",{"2":{"25":1,"28":1}}],["算法描述",{"0":{"25":1}}],["算法步骤",{"0":{"4":1,"9":1,"14":1,"24":1,"28":1}}],["插入数据",{"2":{"27":1}}],["插入新元素",{"2":{"24":1}}],["插入排序在实现上",{"2":{"20":1}}],["插入排序是一种最简单的排序算法",{"2":{"20":1}}],["插入排序的python实现",{"2":{"16":1}}],["插入排序",{"0":{"16":1,"20":1},"1":{"24":1,"27":1}}],["已排序",{"2":{"24":1}}],["取出下一个元素",{"2":{"24":1}}],["gt",{"2":{"23":1}}],["当left",{"2":{"23":1}}],["当前指向的数cur",{"2":{"23":1}}],["则cur++",{"2":{"23":1}}],["则more",{"2":{"23":1}}],["则less++",{"2":{"23":1}}],["循环判断",{"2":{"23":3}}],["初始为right+1",{"2":{"23":1}}],["初始为left",{"2":{"23":2}}],["初始位置分别为两个已经排序序列的起始位置",{"2":{"14":1}}],["定义三个指针",{"2":{"23":1}}],["思路",{"0":{"23":1}}],["选择排序是一种简单直观的排序算法",{"2":{"25":1}}],["选择排序的python实现",{"2":{"21":1}}],["选择排序",{"0":{"21":1},"1":{"25":1,"28":1,"30":1}}],["选择相对小的元素放入到合并空间",{"2":{"14":1}}],["的额外空间",{"2":{"20":1}}],["的一个非常典型的应用",{"2":{"10":1}}],["即只需用到o",{"2":{"20":1}}],["找到插入的位置",{"2":{"27":1}}],["找到相应位置并插入",{"2":{"20":1}}],["找出待排序的数组中最大数",{"2":{"9":1}}],["要求额外空间复杂度o",{"2":{"19":1}}],["等于num的数放在数组的中间",{"2":{"19":1}}],["请把小于num的数放在数组的左边",{"2":{"19":1}}],["和一个数num",{"2":{"19":1}}],["给定一个数组arr",{"2":{"19":1}}],["while",{"2":{"18":3,"27":1,"29":1}}],["tmp",{"2":{"18":6}}],["min",{"2":{"30":5}}],["mid",{"2":{"18":6}}],["more",{"2":{"29":8}}],["merge",{"2":{"18":5}}],["max",{"2":{"13":6}}],["在已经排序的元素序列中从后向前扫描",{"2":{"24":1}}],["在已排序序列中从后向前扫描",{"2":{"20":1}}],["在减少的堆上重新调整堆",{"2":{"17":1}}],["在学习快速排序之前",{"2":{"15":1}}],["交换",{"2":{"17":1}}],["交换堆顶元素和末尾元素",{"2":{"12":1}}],["0",{"2":{"17":4,"18":1,"27":1,"29":2}}],["一个个从堆顶取出元素",{"2":{"17":1}}],["一次比较两个元素",{"2":{"1":1}}],["构建大顶堆",{"2":{"17":1}}],["heap",{"2":{"17":1}}],["heapify",{"2":{"17":4}}],["2",{"2":{"17":4,"18":1}}],["n^2",{"2":{"31":1}}],["num",{"2":{"29":3}}],["nlogn",{"2":{"22":1,"31":1}}],["none",{"2":{"17":1,"18":1,"29":2}}],["n",{"2":{"17":8,"19":1}}],["最大堆实现",{"2":{"17":1}}],["最后的元素会是最大的数",{"2":{"4":1}}],["荷兰国旗问题",{"0":{"19":1},"1":{"23":1},"2":{"15":1}}],["需要先了解一道题",{"2":{"15":1}}],["分别指向小于num的数less",{"2":{"23":1}}],["分别进行排序",{"2":{"15":1}}],["分别对子数组进行排序",{"2":{"10":1}}],["向上一层返回",{"2":{"14":1}}],["释放临时空间",{"2":{"14":1}}],["到原数组中",{"2":{"14":1}}],["到数列的顶端",{"2":{"1":1}}],["对大于基准数的部分进行快速排序",{"2":{"26":1}}],["对小于基准数的部分进行快速排序",{"2":{"26":1}}],["对于未排序数据",{"2":{"20":1}}],["对比两个指针所指向的元素",{"2":{"14":1}}],["对每一对相邻元素作同样的工作",{"2":{"4":1}}],["设定两个指针",{"2":{"14":1}}],["该元素可以认为已经被排序",{"2":{"24":1}}],["该空间用来存放合并后的序列",{"2":{"14":1}}],["该算法是采用分治法",{"2":{"10":1}}],["使其大小为两个已经排序序列之和",{"2":{"14":1}}],["使其满足大顶堆定义",{"2":{"12":1}}],["申请空间",{"2":{"14":1}}],["zfill",{"2":{"13":1}}],["x",{"2":{"13":9}}],["x3c",{"2":{"13":1,"17":2,"18":5,"29":2,"30":1}}],["select",{"2":{"30":1}}],["sublist",{"2":{"13":2}}],["str",{"2":{"13":2}}],["sort",{"2":{"8":1,"13":1,"17":1,"18":1,"27":1,"29":1,"30":1}}],["bucket",{"2":{"13":4}}],["bubble",{"2":{"8":1}}],["val",{"2":{"13":2}}],["randint",{"2":{"29":1}}],["random",{"2":{"29":1}}],["range",{"2":{"8":2,"13":3,"17":2,"27":1,"30":2}}],["recursion",{"2":{"29":4}}],["return",{"2":{"13":2,"17":1,"18":1,"29":2}}],["right时",{"2":{"23":1}}],["right+1",{"2":{"18":1}}],["right",{"2":{"17":4,"18":6,"29":9}}],["less",{"2":{"29":7}}],["left",{"2":{"17":4,"18":6,"29":16}}],["len",{"2":{"8":2,"13":5,"17":1,"18":1,"27":1,"29":1,"30":2}}],["largest",{"2":{"17":9}}],["list",{"2":{"13":2,"17":3,"29":2}}],["current",{"2":{"27":3}}],["cur++",{"2":{"23":1}}],["cardinality",{"2":{"13":1}}],["conquer",{"2":{"10":1}}],["code",{"0":{"8":1,"13":1,"18":1,"27":1,"30":1}}],["3",{"2":{"12":1,"29":1}}],["快速排序的时间复杂度最差为o",{"2":{"31":1}}],["快速排序的python实现",{"2":{"11":1}}],["快速排序是利用了分治的思想",{"2":{"15":1}}],["快速排序",{"0":{"11":1,"15":1,"26":1},"1":{"15":1,"19":1,"23":1,"26":1,"29":1,"31":1}}],["它的工作原理如下",{"2":{"25":1}}],["它的工作原理是通过构建有序序列",{"2":{"20":1}}],["它将数组分成两个子数组",{"2":{"10":1}}],["它重复地走访过要排序的数列",{"2":{"1":1}}],["append",{"2":{"13":1,"18":4}}],["and",{"2":{"10":1,"17":2,"18":1,"27":1}}],["arr",{"2":{"8":9,"13":11,"17":19,"18":9,"27":7,"29":19,"30":9}}],["divide",{"2":{"10":1}}],["def",{"2":{"8":1,"13":1,"17":2,"18":2,"27":1,"29":3,"30":1}}],["重复步骤3",{"2":{"24":1}}],["重复步骤2~5",{"2":{"24":1}}],["重复步骤2~5直到所有位数排序完成",{"2":{"9":1}}],["重复步骤2",{"2":{"12":1}}],["重新调整结构",{"2":{"12":1}}],["重建堆的操作",{"2":{"7":1}}],["返回结果",{"2":{"9":1}}],["合并临时空间中的数据",{"2":{"14":1}}],["合并",{"2":{"9":1}}],["按照位数排序",{"2":{"9":1}}],["计算出位数",{"2":{"9":1}}],["并取得这个数的位数",{"2":{"9":1}}],["=",{"2":{"8":1,"13":8,"17":9,"18":8,"23":1,"27":5,"29":9,"30":3}}],["+=",{"2":{"18":4,"29":3}}],["+",{"2":{"8":3,"17":2,"18":3,"27":2,"29":5,"30":1}}],[">=",{"2":{"18":1,"27":1,"29":1}}],[">",{"2":{"8":1,"13":1,"17":4,"18":1,"27":1,"29":4}}],["10",{"2":{"13":2}}],["1",{"2":{"8":4,"13":4,"17":6,"18":7,"19":1,"20":1,"23":1,"27":5,"29":15,"30":1}}],["1个元素重新构造成一个堆",{"2":{"7":1}}],["j",{"2":{"8":7,"18":8,"30":3}}],["item",{"2":{"13":2}}],["if",{"2":{"8":1,"13":1,"17":3,"18":2,"29":2,"30":1}}],["index",{"2":{"29":4,"30":5}}],["insert",{"2":{"27":1}}],["int",{"2":{"13":2,"17":2,"18":2,"29":6}}],["in",{"2":{"8":2,"13":9,"17":2,"27":1,"30":2}}],["i",{"2":{"8":2,"13":2,"17":13,"18":8,"27":3,"30":5}}],["for",{"2":{"8":2,"13":9,"17":2,"27":1,"30":2}}],["排序完成",{"2":{"7":1}}],["直到所有元素均排序完毕",{"2":{"25":1,"28":1}}],["直到找到已排序的元素小于或者等于新元素的位置",{"2":{"24":1}}],["直到有一个序列的元素全部处理完毕",{"2":{"14":1}}],["直到子数组的长度为1",{"2":{"14":1,"26":1}}],["直到排序完成",{"2":{"12":1}}],["直到",{"2":{"7":1}}],["直到没有任何一对数字需要比较",{"2":{"4":1}}],["直到没有再需要交换",{"2":{"1":1}}],["如此反复进行交换",{"2":{"7":1}}],["如果该元素",{"2":{"24":1}}],["如果cur等于num",{"2":{"23":1}}],["如果cur大于num",{"2":{"23":1}}],["如果cur小于num",{"2":{"23":1}}],["如果第一个比第二个大",{"2":{"4":1}}],["如果他们的顺序错误就把他们交换过来",{"2":{"1":1}}],["将数组分为三个部分",{"2":{"26":1}}],["将数组分为两个部分",{"2":{"15":1}}],["将该元素移到下一位置",{"2":{"24":1}}],["将无序序列构造成一个大顶堆",{"2":{"12":1}}],["将其与末尾元素进行交换",{"2":{"7":1}}],["将待排序序列构造成一个大顶堆",{"2":{"7":1}}],["整个序列的最大值就是堆顶的根节点",{"2":{"7":1}}],["此时末尾",{"2":{"7":1}}],["此时",{"2":{"7":1}}],["归并排序是一种稳定的排序方法",{"2":{"10":1}}],["归并排序是建立在归并操作上的一种有效的排序算法",{"2":{"10":1}}],["归并排序的python实现",{"2":{"6":1}}],["归并排序",{"0":{"6":1,"10":1},"1":{"10":1,"14":1,"18":1}}],["数列就变成一个有序序列",{"2":{"5":1}}],["数位较短的数前面补零",{"2":{"5":1}}],["依次进行一次排序",{"2":{"5":1}}],["从第一个元素开始",{"2":{"24":1}}],["从最低位开始",{"2":{"5":1}}],["从开始第一对到结尾的最后一对",{"2":{"4":1}}],["然后再从剩余未排序元素中继续寻找最小",{"2":{"28":1}}],["然后放到已排序序列的末尾",{"2":{"25":1,"28":1}}],["然后合并",{"2":{"15":1}}],["然后合并两个有序的子数组",{"2":{"10":1}}],["然后将剩余n",{"2":{"7":1}}],["然后",{"2":{"5":1,"25":1}}],["统一为同样的数位长度",{"2":{"5":1}}],["正整数",{"2":{"5":1}}],["其原理是将所有待比较数值",{"2":{"5":1}}],["持续每次对越来越少的元素重复上面的步骤",{"2":{"4":1}}],["除了最后一个",{"2":{"4":1}}],["针对所有的元素重复以上的步骤",{"2":{"4":1}}],["这样会得到n个元素的次小值",{"2":{"7":1}}],["这样从最低位排序一直到最高位排序完成以后",{"2":{"5":1}}],["这步做完后",{"2":{"4":1}}],["这个算法的名字由来是因为越小的元素会经由交换慢慢",{"2":{"1":1}}],["就交换他们两个",{"2":{"4":1}}],["比较相邻的元素",{"2":{"4":1}}],["堆排序时间复杂度",{"0":{"22":1}}],["堆排序实现",{"0":{"17":1}}],["堆排序流程",{"0":{"12":1}}],["堆排序的时间复杂度为o",{"2":{"22":1}}],["堆排序的基本思想是",{"2":{"7":1}}],["堆排序的python实现",{"2":{"3":1}}],["堆排序是一种选择排序",{"2":{"7":1}}],["堆排序是利用堆这种数据结构而设计的一种排序算法",{"2":{"7":1}}],["堆排序",{"0":{"3":1,"7":1},"1":{"7":1,"12":1,"17":1,"22":1}}],["基数排序是一种非比较型排序算法",{"2":{"5":1}}],["基数排序的python实现",{"2":{"2":1}}],["基数排序",{"0":{"2":1,"5":1},"1":{"5":1,"9":1,"13":1}}],["浮",{"2":{"1":1}}],["也就是说该数列已经排序完成",{"2":{"1":1}}],["走访数列的工作是重复地进行",{"2":{"1":1}}],["冒泡排序是一种简单的排序算法",{"2":{"1":1}}],["冒泡排序的python实现",{"2":{"0":1}}],["冒泡排序",{"0":{"0":1,"1":1},"1":{"1":1,"4":1,"8":1}}]],"serializationVersion":2}';export{t as default};
