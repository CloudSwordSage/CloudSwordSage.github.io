const t='{"documentCount":25,"nextId":25,"documentIds":{"0":"/article/5072dy3i/#冒泡排序","1":"/article/5072dy3i/#算法步骤","2":"/article/zcuvoi0z/#基数排序","3":"/article/33zhvues/#堆排序","4":"/article/5072dy3i/#code","5":"/article/zcuvoi0z/#算法步骤","6":"/article/fslzy69j/#归并排序","7":"/article/33zhvues/#堆排序流程","8":"/article/zcuvoi0z/#code","9":"/article/fslzy69j/#算法步骤","10":"/article/su2chqg1/#快速排序","11":"/article/33zhvues/#堆排序实现","12":"/article/fslzy69j/#code","13":"/article/su2chqg1/#荷兰国旗问题","14":"/article/jbadeaso/#插入排序","15":"/article/33zhvues/#堆排序时间复杂度","16":"/article/su2chqg1/#思路","17":"/article/jbadeaso/#算法步骤","18":"/article/4we28dl1/#算法描述","19":"/article/su2chqg1/#快速排序-1","20":"/article/jbadeaso/#code","21":"/article/4we28dl1/#算法步骤","22":"/article/su2chqg1/#代码实现","23":"/article/4we28dl1/#code","24":"/article/su2chqg1/#复杂度分析"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,11],"1":[1,1,12],"2":[1,1,11],"3":[1,1,17],"4":[1,1,16],"5":[1,1,8],"6":[1,1,11],"7":[1,1,8],"8":[1,1,28],"9":[1,1,16],"10":[1,1,8],"11":[1,1,33],"12":[1,1,30],"13":[1,1,10],"14":[1,1,12],"15":[1,1,3],"16":[1,2,21],"17":[1,1,13],"18":[1,1,12],"19":[1,1,10],"20":[1,1,23],"21":[1,1,9],"22":[1,1,34],"23":[1,1,18],"24":[1,1,7]},"averageFieldLength":[1,1.04,15.24],"storedFields":{"0":{"title":"冒泡排序","titles":[null]},"1":{"title":"算法步骤","titles":[null]},"2":{"title":"基数排序","titles":[null]},"3":{"title":"堆排序","titles":[null]},"4":{"title":"CODE","titles":[null]},"5":{"title":"算法步骤","titles":[null]},"6":{"title":"归并排序","titles":[null]},"7":{"title":"堆排序流程","titles":[null]},"8":{"title":"CODE","titles":[null]},"9":{"title":"算法步骤","titles":[null]},"10":{"title":"快速排序","titles":[null]},"11":{"title":"堆排序实现","titles":[null]},"12":{"title":"CODE","titles":[null]},"13":{"title":"荷兰国旗问题","titles":[null]},"14":{"title":"插入排序","titles":[]},"15":{"title":"堆排序时间复杂度","titles":[null]},"16":{"title":"思路","titles":[null,"荷兰国旗问题"]},"17":{"title":"算法步骤","titles":["插入排序"]},"18":{"title":"算法描述","titles":[null]},"19":{"title":"快速排序","titles":[null]},"20":{"title":"CODE","titles":["插入排序"]},"21":{"title":"算法步骤","titles":[null]},"22":{"title":"代码实现","titles":[null]},"23":{"title":"CODE","titles":[null]},"24":{"title":"复杂度分析","titles":[null]}},"dirtCount":0,"index":[["时间复杂度为o",{"2":{"24":1}}],["时间复杂度o",{"2":{"13":1}}],["通过计算数学期望",{"2":{"24":1}}],["通常采用in",{"2":{"14":1}}],["但由于快速排序使用了随机数",{"2":{"24":1}}],["复杂度分析",{"0":{"24":1}}],["elif",{"2":{"22":1}}],["else",{"2":{"12":1,"22":1}}],["quick",{"2":{"22":1}}],["代码实现",{"0":{"22":1}}],["移动数据",{"2":{"20":1}}],["移动指针",{"2":{"9":1}}],["pivot",{"2":{"22":6}}],["partition",{"2":{"22":2}}],["preindex",{"2":{"20":7}}],["place算法方式",{"2":{"14":1}}],["结束递归",{"2":{"19":1}}],["结束循环",{"2":{"16":1}}],["递归调用",{"2":{"19":2}}],["递归分解数组",{"2":{"9":1}}],["以基准数作为荷兰国旗问题的num",{"2":{"19":1}}],["以此类推",{"2":{"18":1,"21":1}}],["作为基准数",{"2":{"19":1}}],["随机选择一个数",{"2":{"19":1}}],["再从剩余未排序元素中继续寻找最小",{"2":{"18":1}}],["存放到排序序列的起始位置",{"2":{"18":1,"21":1}}],["元素",{"2":{"18":2,"21":2}}],["元素就变成了最大值",{"2":{"3":1}}],["大",{"2":{"18":2,"21":2}}],["大于新元素",{"2":{"17":1}}],["大于num的数more",{"2":{"16":1}}],["大于num的数放在数组的右边",{"2":{"13":1}}],["首先在未排序序列中找到最小",{"2":{"18":1,"21":1}}],["选择排序是一种简单直观的排序算法",{"2":{"18":1}}],["选择相对小的元素放入到合并空间",{"2":{"9":1}}],["算法描述",{"0":{"18":1}}],["算法步骤",{"0":{"1":1,"5":1,"9":1,"17":1,"21":1}}],["插入数据",{"2":{"20":1}}],["插入新元素",{"2":{"17":1}}],["插入排序在实现上",{"2":{"14":1}}],["插入排序是一种最简单的排序算法",{"2":{"14":1}}],["插入排序",{"0":{"14":1},"1":{"17":1,"20":1}}],["已排序",{"2":{"17":1}}],["取出下一个元素",{"2":{"17":1}}],["gt",{"2":{"16":1}}],["当left",{"2":{"16":1}}],["当前指向的数cur",{"2":{"16":1}}],["则cur++",{"2":{"16":1}}],["则more",{"2":{"16":1}}],["则less++",{"2":{"16":1}}],["循环判断",{"2":{"16":3}}],["初始为right+1",{"2":{"16":1}}],["初始为left",{"2":{"16":2}}],["初始位置分别为两个已经排序序列的起始位置",{"2":{"9":1}}],["定义三个指针",{"2":{"16":1}}],["思路",{"0":{"16":1}}],["的额外空间",{"2":{"14":1}}],["的一个非常典型的应用",{"2":{"6":1}}],["即只需用到o",{"2":{"14":1}}],["找到插入的位置",{"2":{"20":1}}],["找到相应位置并插入",{"2":{"14":1}}],["找出待排序的数组中最大数",{"2":{"5":1}}],["要求额外空间复杂度o",{"2":{"13":1}}],["等于num的数放在数组的中间",{"2":{"13":1}}],["请把小于num的数放在数组的左边",{"2":{"13":1}}],["和一个数num",{"2":{"13":1}}],["给定一个数组arr",{"2":{"13":1}}],["while",{"2":{"12":3,"20":1,"22":1}}],["tmp",{"2":{"12":6}}],["min",{"2":{"23":5}}],["mid",{"2":{"12":6}}],["more",{"2":{"22":8}}],["merge",{"2":{"12":5}}],["max",{"2":{"8":6}}],["在已经排序的元素序列中从后向前扫描",{"2":{"17":1}}],["在已排序序列中从后向前扫描",{"2":{"14":1}}],["在减少的堆上重新调整堆",{"2":{"11":1}}],["在学习快速排序之前",{"2":{"10":1}}],["交换",{"2":{"11":1}}],["交换堆顶元素和末尾元素",{"2":{"7":1}}],["0",{"2":{"11":4,"12":1,"20":1,"22":2}}],["一个个从堆顶取出元素",{"2":{"11":1}}],["一次比较两个元素",{"2":{"0":1}}],["构建大顶堆",{"2":{"11":1}}],["heap",{"2":{"11":1}}],["heapify",{"2":{"11":4}}],["2",{"2":{"11":4,"12":1}}],["n^2",{"2":{"24":1}}],["num",{"2":{"22":3}}],["nlogn",{"2":{"15":1,"24":1}}],["none",{"2":{"11":1,"12":1,"22":2}}],["n",{"2":{"11":8,"13":1}}],["最大堆实现",{"2":{"11":1}}],["最后的元素会是最大的数",{"2":{"1":1}}],["荷兰国旗问题",{"0":{"13":1},"1":{"16":1},"2":{"10":1}}],["需要先了解一道题",{"2":{"10":1}}],["分别指向小于num的数less",{"2":{"16":1}}],["分别进行排序",{"2":{"10":1}}],["分别对子数组进行排序",{"2":{"6":1}}],["快速排序的时间复杂度最差为o",{"2":{"24":1}}],["快速排序是利用了分治的思想",{"2":{"10":1}}],["快速排序",{"0":{"10":1,"19":1}}],["向上一层返回",{"2":{"9":1}}],["释放临时空间",{"2":{"9":1}}],["到原数组中",{"2":{"9":1}}],["到数列的顶端",{"2":{"0":1}}],["对大于基准数的部分进行快速排序",{"2":{"19":1}}],["对小于基准数的部分进行快速排序",{"2":{"19":1}}],["对于未排序数据",{"2":{"14":1}}],["对比两个指针所指向的元素",{"2":{"9":1}}],["对每一对相邻元素作同样的工作",{"2":{"1":1}}],["设定两个指针",{"2":{"9":1}}],["该元素可以认为已经被排序",{"2":{"17":1}}],["该空间用来存放合并后的序列",{"2":{"9":1}}],["该算法是采用分治法",{"2":{"6":1}}],["使其大小为两个已经排序序列之和",{"2":{"9":1}}],["使其满足大顶堆定义",{"2":{"7":1}}],["申请空间",{"2":{"9":1}}],["zfill",{"2":{"8":1}}],["x",{"2":{"8":9}}],["x3c",{"2":{"8":1,"11":2,"12":5,"22":2,"23":1}}],["select",{"2":{"23":1}}],["sublist",{"2":{"8":2}}],["str",{"2":{"8":2}}],["sort",{"2":{"4":1,"8":1,"11":1,"12":1,"20":1,"22":1,"23":1}}],["bucket",{"2":{"8":4}}],["bubble",{"2":{"4":1}}],["val",{"2":{"8":2}}],["randint",{"2":{"22":1}}],["random",{"2":{"22":1}}],["range",{"2":{"4":2,"8":3,"11":2,"20":1,"23":2}}],["recursion",{"2":{"22":4}}],["return",{"2":{"8":2,"11":1,"12":1,"22":2}}],["right时",{"2":{"16":1}}],["right+1",{"2":{"12":1}}],["right",{"2":{"11":4,"12":6,"22":9}}],["less",{"2":{"22":7}}],["left",{"2":{"11":4,"12":6,"22":16}}],["len",{"2":{"4":2,"8":5,"11":1,"12":1,"20":1,"22":1,"23":2}}],["largest",{"2":{"11":9}}],["list",{"2":{"8":2,"11":3,"22":2}}],["current",{"2":{"20":3}}],["cur++",{"2":{"16":1}}],["cardinality",{"2":{"8":1}}],["conquer",{"2":{"6":1}}],["code",{"0":{"4":1,"8":1,"12":1,"20":1,"23":1}}],["3",{"2":{"7":1,"22":1}}],["它的工作原理如下",{"2":{"18":1}}],["它的工作原理是通过构建有序序列",{"2":{"14":1}}],["它将数组分成两个子数组",{"2":{"6":1}}],["它重复地走访过要排序的数列",{"2":{"0":1}}],["append",{"2":{"8":1,"12":4}}],["and",{"2":{"6":1,"11":2,"12":1,"20":1}}],["arr",{"2":{"4":9,"8":11,"11":19,"12":9,"20":7,"22":19,"23":9}}],["divide",{"2":{"6":1}}],["def",{"2":{"4":1,"8":1,"11":2,"12":2,"20":1,"22":3,"23":1}}],["归并排序是一种稳定的排序方法",{"2":{"6":1}}],["归并排序是建立在归并操作上的一种有效的排序算法",{"2":{"6":1}}],["归并排序",{"0":{"6":1}}],["重复步骤3",{"2":{"17":1}}],["重复步骤2~5",{"2":{"17":1}}],["重复步骤2~5直到所有位数排序完成",{"2":{"5":1}}],["重复步骤2",{"2":{"7":1}}],["重新调整结构",{"2":{"7":1}}],["重建堆的操作",{"2":{"3":1}}],["返回结果",{"2":{"5":1}}],["合并临时空间中的数据",{"2":{"9":1}}],["合并",{"2":{"5":1}}],["按照位数排序",{"2":{"5":1}}],["计算出位数",{"2":{"5":1}}],["并取得这个数的位数",{"2":{"5":1}}],["=",{"2":{"4":1,"8":8,"11":9,"12":8,"16":1,"20":5,"22":9,"23":3}}],["+=",{"2":{"12":4,"22":3}}],["+",{"2":{"4":3,"11":2,"12":3,"20":2,"22":5,"23":1}}],[">=",{"2":{"12":1,"20":1,"22":1}}],[">",{"2":{"4":1,"8":1,"11":4,"12":1,"20":1,"22":4}}],["10",{"2":{"8":2}}],["1",{"2":{"4":4,"8":4,"11":6,"12":7,"13":1,"14":1,"16":1,"20":5,"22":15,"23":1}}],["1个元素重新构造成一个堆",{"2":{"3":1}}],["j",{"2":{"4":7,"12":8,"23":3}}],["item",{"2":{"8":2}}],["if",{"2":{"4":1,"8":1,"11":3,"12":2,"22":2,"23":1}}],["index",{"2":{"22":4,"23":5}}],["insert",{"2":{"20":1}}],["int",{"2":{"8":2,"11":2,"12":2,"22":6}}],["in",{"2":{"4":2,"8":9,"11":2,"20":1,"23":2}}],["i",{"2":{"4":2,"8":2,"11":13,"12":8,"20":3,"23":5}}],["for",{"2":{"4":2,"8":9,"11":2,"20":1,"23":2}}],["排序完成",{"2":{"3":1}}],["直到所有元素均排序完毕",{"2":{"18":1,"21":1}}],["直到找到已排序的元素小于或者等于新元素的位置",{"2":{"17":1}}],["直到有一个序列的元素全部处理完毕",{"2":{"9":1}}],["直到子数组的长度为1",{"2":{"9":1,"19":1}}],["直到排序完成",{"2":{"7":1}}],["直到",{"2":{"3":1}}],["直到没有任何一对数字需要比较",{"2":{"1":1}}],["直到没有再需要交换",{"2":{"0":1}}],["如此反复进行交换",{"2":{"3":1}}],["如果该元素",{"2":{"17":1}}],["如果cur等于num",{"2":{"16":1}}],["如果cur大于num",{"2":{"16":1}}],["如果cur小于num",{"2":{"16":1}}],["如果第一个比第二个大",{"2":{"1":1}}],["如果他们的顺序错误就把他们交换过来",{"2":{"0":1}}],["将数组分为三个部分",{"2":{"19":1}}],["将数组分为两个部分",{"2":{"10":1}}],["将该元素移到下一位置",{"2":{"17":1}}],["将无序序列构造成一个大顶堆",{"2":{"7":1}}],["将其与末尾元素进行交换",{"2":{"3":1}}],["将待排序序列构造成一个大顶堆",{"2":{"3":1}}],["整个序列的最大值就是堆顶的根节点",{"2":{"3":1}}],["此时末尾",{"2":{"3":1}}],["此时",{"2":{"3":1}}],["堆排序的时间复杂度为o",{"2":{"15":1}}],["堆排序的基本思想是",{"2":{"3":1}}],["堆排序时间复杂度",{"0":{"15":1}}],["堆排序实现",{"0":{"11":1}}],["堆排序流程",{"0":{"7":1}}],["堆排序是一种选择排序",{"2":{"3":1}}],["堆排序是利用堆这种数据结构而设计的一种排序算法",{"2":{"3":1}}],["堆排序",{"0":{"3":1}}],["数列就变成一个有序序列",{"2":{"2":1}}],["数位较短的数前面补零",{"2":{"2":1}}],["依次进行一次排序",{"2":{"2":1}}],["从第一个元素开始",{"2":{"17":1}}],["从最低位开始",{"2":{"2":1}}],["从开始第一对到结尾的最后一对",{"2":{"1":1}}],["然后再从剩余未排序元素中继续寻找最小",{"2":{"21":1}}],["然后放到已排序序列的末尾",{"2":{"18":1,"21":1}}],["然后合并",{"2":{"10":1}}],["然后合并两个有序的子数组",{"2":{"6":1}}],["然后将剩余n",{"2":{"3":1}}],["然后",{"2":{"2":1,"18":1}}],["统一为同样的数位长度",{"2":{"2":1}}],["正整数",{"2":{"2":1}}],["其原理是将所有待比较数值",{"2":{"2":1}}],["基数排序是一种非比较型排序算法",{"2":{"2":1}}],["基数排序",{"0":{"2":1}}],["持续每次对越来越少的元素重复上面的步骤",{"2":{"1":1}}],["除了最后一个",{"2":{"1":1}}],["针对所有的元素重复以上的步骤",{"2":{"1":1}}],["这样会得到n个元素的次小值",{"2":{"3":1}}],["这样从最低位排序一直到最高位排序完成以后",{"2":{"2":1}}],["这步做完后",{"2":{"1":1}}],["这个算法的名字由来是因为越小的元素会经由交换慢慢",{"2":{"0":1}}],["就交换他们两个",{"2":{"1":1}}],["比较相邻的元素",{"2":{"1":1}}],["浮",{"2":{"0":1}}],["也就是说该数列已经排序完成",{"2":{"0":1}}],["走访数列的工作是重复地进行",{"2":{"0":1}}],["冒泡排序是一种简单的排序算法",{"2":{"0":1}}],["冒泡排序",{"0":{"0":1}}]],"serializationVersion":2}';export{t as default};
